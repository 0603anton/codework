#include <iostream>
#include <biginteger.cpp>
#include <ctime>
using namespace std;

int main(int argc, char *argv[]) {

    if (argc != 3 && argv[1] != "-n") {
        cout << "неверные входные параметры \n";
        return 0;
    }

    BigInteger n(argv[2]); // исходное натуральное число
    bool prm = true; // вероятность того, что число простое


    if ( // если имеются простые делители

         (n == 1)               ||
         (n != 2 && n % 2 == 0) ||
         (n != 3 && n % 3 == 0) ||
         (n != 5 && n % 5 == 0) ||
         (n != 7 && n % 7 == 0)

    ) prm = false;

    if (!prm) {
        cout << "число не является простым \n";
        return 0;
    }

    // исключаем первые простые числа для правильной работы
    // перебора делителей в цикле
    if (n == 3 || n == 5 || n == 7 || n == 11 || n == 13) {
        cout << "число является простым \n";
        return 0;
    }

    // корень числа n
    BigInteger q = n.sqrt() + 1;

    // полупростые числа
    // в диапазоне от [3 .. q]
    BigInteger p = 3;

    // простые делители
    // начинаются с тройки
    // p - простые числа Чена
    // такие простые числа p,
    // что p + 2 либо простое,
    // либо полупростое

    for ( ; p <= q; p = p + 12 ) {

        // все четные делители и все делители,
        // кратные простым числам, могут быть опущены

        if ( // благодаря такому подходу,
             // время вычислений уменьшается
             // в силу того, что количество
             // итераций сокращается

             n % (p    )  == 0  || // n mod 3, ..
             n % (p + 2)  == 0  || // n mod 5, ..
             n % (p + 4)  == 0  || // n mod 7, ..
             n % (p + 6)  == 0  || // n mod 9, ..
             n % (p + 8)  == 0  || // n mod 11, ..
             n % (p + 10) == 0     // n mod 13, ..

        ) { prm = false; break; }

    }

    if (prm) cout << "число является простым \n";
    else cout << "число не является простым \n";

    return 0;
}
