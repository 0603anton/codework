<h3>Оглавление</h3>
<a href="#one">1. Постановка задачи</a><br>
<a href="#two">&nbsp;&nbsp;&nbsp;1.1. Пример работы</a><br>
<a href="#three">2. Теория</a><br>
<a href="#four">&nbsp;&nbsp;&nbsp;2.1. λ-исчисление</a><br>
<a href="#five">&nbsp;&nbsp;&nbsp;2.2. Связь с рекурсивными функциями</a><br>
<a href="#six">&nbsp;&nbsp;&nbsp;2.3. Примеры работы</a><br>

<h3 id="one">1. Реализовать интерпретатор лямбда-исчислений</h3>
<p>Программа должна уметь работать с вложенными лямбда-функциями, а также иметь графический интерфейс.
</p>

<b id="two">1.1. Пример работы</b> <br>
<p></p>

<h3 id="three">2. Теория</h3>
<b id="four">2.1. λ-исчисление</b><br>
формальная система, разработанная американским математиком Алонзо Чёрчем, для формализации и анализа понятия вычислимости.

λ-исчисление может рассматриваться как семейство прототипных языков программирования. Их основная особенность состоит в том, что они являются языками высших порядков. Тем самым обеспечивается систематический подход к исследованию операторов, аргументами которых могут быть другие операторы, а значением также может быть оператор. Языки в этом семействе являются функциональными, поскольку они основаны на представлении о функции или операторе, включая функциональную аппликацию и функциональную абстракцию.

<br>
<b id="five">2.2. Связь с рекурсивными функциями</b> <br>
Рекурсия — это определение функции через себя; на первый взгляд, лямбда-исчисление не позволяет этого, но это впечатление обманчиво. Например, рассмотрим рекурсивную функцию, вычисляющую факториал:

```text
f(n) = 1, if n = 0; else n × f(n - 1)
```

В лямбда-исчислении, Y g — неподвижная точка g; продемонстрируем это:

```text
Y g
(λh.(λx.h (x x)) (λx.h (x x))) g
(λx.g (x x)) (λx.g (x x))
g ((λx.g (x x)) (λx.g (x x)))
g (Y g)
```

<br>
<b id="six">2.3. Пример</b> <br>
```text

```
<br>